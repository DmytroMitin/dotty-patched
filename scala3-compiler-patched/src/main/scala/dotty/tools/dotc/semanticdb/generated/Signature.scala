// Generated by https://github.com/tanishiking/semanticdb-for-scala3
// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package dotty.tools.dotc.semanticdb
import dotty.tools.dotc.semanticdb.internal._
import scala.annotation.internal.sharable

sealed trait Signature  extends SemanticdbGeneratedSealedOneof  derives CanEqual {
  type MessageType = dotty.tools.dotc.semanticdb.SignatureMessage
  final def isEmpty = this.isInstanceOf[dotty.tools.dotc.semanticdb.Signature.Empty.type]
  final def isDefined = !isEmpty
  final def asMessage: dotty.tools.dotc.semanticdb.SignatureMessage = dotty.tools.dotc.semanticdb.Signature.SignatureTypeMapper.toBase(this)
  final def asNonEmpty: Option[dotty.tools.dotc.semanticdb.Signature.NonEmpty] = if (isEmpty) None else Some(this.asInstanceOf[dotty.tools.dotc.semanticdb.Signature.NonEmpty])
}

object Signature {
  case object Empty extends dotty.tools.dotc.semanticdb.Signature
  
  sealed trait NonEmpty extends dotty.tools.dotc.semanticdb.Signature
  def defaultInstance: dotty.tools.dotc.semanticdb.Signature = Empty
  
  implicit val SignatureTypeMapper: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.SignatureMessage, dotty.tools.dotc.semanticdb.Signature] = new SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.SignatureMessage, dotty.tools.dotc.semanticdb.Signature] {
    override def toCustom(__base: dotty.tools.dotc.semanticdb.SignatureMessage): dotty.tools.dotc.semanticdb.Signature = __base.sealedValue match {
      case __v: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ClassSignature => __v.value
      case __v: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.MethodSignature => __v.value
      case __v: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.TypeSignature => __v.value
      case __v: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ValueSignature => __v.value
      case dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.Empty => Empty
    }
    override def toBase(__custom: dotty.tools.dotc.semanticdb.Signature): dotty.tools.dotc.semanticdb.SignatureMessage = dotty.tools.dotc.semanticdb.SignatureMessage(__custom match {
      case __v: dotty.tools.dotc.semanticdb.ClassSignature => dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ClassSignature(__v)
      case __v: dotty.tools.dotc.semanticdb.MethodSignature => dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.MethodSignature(__v)
      case __v: dotty.tools.dotc.semanticdb.TypeSignature => dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.TypeSignature(__v)
      case __v: dotty.tools.dotc.semanticdb.ValueSignature => dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ValueSignature(__v)
      case Empty => dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.Empty
    })
  }
}
@SerialVersionUID(0L)
final case class SignatureMessage(
    sealedValue: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.Empty
    )  extends SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (sealedValue.classSignature.isDefined) {
        val __value = sealedValue.classSignature.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.methodSignature.isDefined) {
        val __value = sealedValue.methodSignature.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.typeSignature.isDefined) {
        val __value = sealedValue.typeSignature.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.valueSignature.isDefined) {
        val __value = sealedValue.valueSignature.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      sealedValue.classSignature.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.methodSignature.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.typeSignature.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.valueSignature.foreach { __v =>
        val __m = __v
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def getClassSignature: dotty.tools.dotc.semanticdb.ClassSignature = sealedValue.classSignature.getOrElse(dotty.tools.dotc.semanticdb.ClassSignature.defaultInstance)
    def withClassSignature(__v: dotty.tools.dotc.semanticdb.ClassSignature): SignatureMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ClassSignature(__v))
    def getMethodSignature: dotty.tools.dotc.semanticdb.MethodSignature = sealedValue.methodSignature.getOrElse(dotty.tools.dotc.semanticdb.MethodSignature.defaultInstance)
    def withMethodSignature(__v: dotty.tools.dotc.semanticdb.MethodSignature): SignatureMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.MethodSignature(__v))
    def getTypeSignature: dotty.tools.dotc.semanticdb.TypeSignature = sealedValue.typeSignature.getOrElse(dotty.tools.dotc.semanticdb.TypeSignature.defaultInstance)
    def withTypeSignature(__v: dotty.tools.dotc.semanticdb.TypeSignature): SignatureMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.TypeSignature(__v))
    def getValueSignature: dotty.tools.dotc.semanticdb.ValueSignature = sealedValue.valueSignature.getOrElse(dotty.tools.dotc.semanticdb.ValueSignature.defaultInstance)
    def withValueSignature(__v: dotty.tools.dotc.semanticdb.ValueSignature): SignatureMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ValueSignature(__v))
    def clearSealedValue: SignatureMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.Empty)
    def withSealedValue(__v: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue): SignatureMessage = copy(sealedValue = __v)
    
    
    
    
    def toSignature: dotty.tools.dotc.semanticdb.Signature = dotty.tools.dotc.semanticdb.Signature.SignatureTypeMapper.toCustom(this)
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.Signature])
}

object SignatureMessage  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SignatureMessage] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SignatureMessage] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.SignatureMessage = {
    var __sealedValue: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.Empty
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ClassSignature(__sealedValue.classSignature.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.ClassSignature](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.MethodSignature(__sealedValue.methodSignature.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.MethodSignature](_input__))(LiteParser.readMessage(_input__, _)))
        case 26 =>
          __sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.TypeSignature(__sealedValue.typeSignature.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeSignature](_input__))(LiteParser.readMessage(_input__, _)))
        case 34 =>
          __sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.ValueSignature(__sealedValue.valueSignature.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.ValueSignature](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.SignatureMessage(
        sealedValue = __sealedValue
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.SignatureMessage(
    sealedValue = dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue.Empty
  )
  sealed trait SealedValue  extends SemanticdbGeneratedOneof  derives CanEqual {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isClassSignature: _root_.scala.Boolean = false
    def isMethodSignature: _root_.scala.Boolean = false
    def isTypeSignature: _root_.scala.Boolean = false
    def isValueSignature: _root_.scala.Boolean = false
    def classSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.ClassSignature] = _root_.scala.None
    def methodSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.MethodSignature] = _root_.scala.None
    def typeSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeSignature] = _root_.scala.None
    def valueSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.ValueSignature] = _root_.scala.None
  }
  object SealedValue {
    @SerialVersionUID(0L)
    case object Empty extends dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class ClassSignature(value: dotty.tools.dotc.semanticdb.ClassSignature) extends dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.ClassSignature
      override def isClassSignature: _root_.scala.Boolean = true
      override def classSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.ClassSignature] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class MethodSignature(value: dotty.tools.dotc.semanticdb.MethodSignature) extends dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.MethodSignature
      override def isMethodSignature: _root_.scala.Boolean = true
      override def methodSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.MethodSignature] = Some(value)
      override def number: _root_.scala.Int = 2
    }
    @SerialVersionUID(0L)
    final case class TypeSignature(value: dotty.tools.dotc.semanticdb.TypeSignature) extends dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.TypeSignature
      override def isTypeSignature: _root_.scala.Boolean = true
      override def typeSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeSignature] = Some(value)
      override def number: _root_.scala.Int = 3
    }
    @SerialVersionUID(0L)
    final case class ValueSignature(value: dotty.tools.dotc.semanticdb.ValueSignature) extends dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.ValueSignature
      override def isValueSignature: _root_.scala.Boolean = true
      override def valueSignature: _root_.scala.Option[dotty.tools.dotc.semanticdb.ValueSignature] = Some(value)
      override def number: _root_.scala.Int = 4
    }
  }
  final val CLASS_SIGNATURE_FIELD_NUMBER = 1
  final val METHOD_SIGNATURE_FIELD_NUMBER = 2
  final val TYPE_SIGNATURE_FIELD_NUMBER = 3
  final val VALUE_SIGNATURE_FIELD_NUMBER = 4
  def of(
    sealedValue: dotty.tools.dotc.semanticdb.SignatureMessage.SealedValue
  ): _root_.dotty.tools.dotc.semanticdb.SignatureMessage = _root_.dotty.tools.dotc.semanticdb.SignatureMessage(
    sealedValue
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.Signature])
}

@SerialVersionUID(0L)
final case class ClassSignature(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None,
    parents: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type] = _root_.scala.Seq.empty,
    self: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.ClassSignature._typemapper_self.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    )  extends dotty.tools.dotc.semanticdb.Signature.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (typeParameters.isDefined) {
        val __value = typeParameters.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      parents.foreach { __item =>
        val __value = dotty.tools.dotc.semanticdb.ClassSignature._typemapper_parents.toBase(__item)
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      
      {
        val __value = dotty.tools.dotc.semanticdb.ClassSignature._typemapper_self.toBase(self)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      if (declarations.isDefined) {
        val __value = declarations.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      typeParameters.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      parents.foreach { __v =>
        val __m = dotty.tools.dotc.semanticdb.ClassSignature._typemapper_parents.toBase(__v)
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = dotty.tools.dotc.semanticdb.ClassSignature._typemapper_self.toBase(self)
        if (__v.serializedSize != 0) {
          _output__.writeTag(3, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      declarations.foreach { __v =>
        val __m = __v
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def getTypeParameters: dotty.tools.dotc.semanticdb.Scope = typeParameters.getOrElse(dotty.tools.dotc.semanticdb.Scope.defaultInstance)
    def clearTypeParameters: ClassSignature = copy(typeParameters = _root_.scala.None)
    def withTypeParameters(__v: dotty.tools.dotc.semanticdb.Scope): ClassSignature = copy(typeParameters = Option(__v))
    def clearParents = copy(parents = _root_.scala.Seq.empty)
    def addParents(__vs: dotty.tools.dotc.semanticdb.Type *): ClassSignature = addAllParents(__vs)
    def addAllParents(__vs: Iterable[dotty.tools.dotc.semanticdb.Type]): ClassSignature = copy(parents = parents ++ __vs)
    def withParents(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]): ClassSignature = copy(parents = __v)
    def withSelf(__v: dotty.tools.dotc.semanticdb.Type): ClassSignature = copy(self = __v)
    def getDeclarations: dotty.tools.dotc.semanticdb.Scope = declarations.getOrElse(dotty.tools.dotc.semanticdb.Scope.defaultInstance)
    def clearDeclarations: ClassSignature = copy(declarations = _root_.scala.None)
    def withDeclarations(__v: dotty.tools.dotc.semanticdb.Scope): ClassSignature = copy(declarations = Option(__v))
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.ClassSignature])
}

object ClassSignature  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ClassSignature] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ClassSignature] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.ClassSignature = {
    var __typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    val __parents: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type]
    var __self: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var __declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __typeParameters = Option(__typeParameters.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __parents += dotty.tools.dotc.semanticdb.ClassSignature._typemapper_parents.toCustom(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))
        case 26 =>
          __self = _root_.scala.Some(__self.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 34 =>
          __declarations = Option(__declarations.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.ClassSignature(
        typeParameters = __typeParameters,
        parents = __parents.result(),
        self = dotty.tools.dotc.semanticdb.ClassSignature._typemapper_self.toCustom(__self.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        declarations = __declarations
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.ClassSignature(
    typeParameters = _root_.scala.None,
    parents = _root_.scala.Seq.empty,
    self = dotty.tools.dotc.semanticdb.ClassSignature._typemapper_self.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    declarations = _root_.scala.None
  )
  final val TYPE_PARAMETERS_FIELD_NUMBER = 1
  final val PARENTS_FIELD_NUMBER = 2
  final val SELF_FIELD_NUMBER = 3
  final val DECLARATIONS_FIELD_NUMBER = 4
  @transient @sharable
  private[semanticdb] val _typemapper_parents: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  @transient @sharable
  private[semanticdb] val _typemapper_self: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope],
    parents: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type],
    self: dotty.tools.dotc.semanticdb.Type,
    declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope]
  ): _root_.dotty.tools.dotc.semanticdb.ClassSignature = _root_.dotty.tools.dotc.semanticdb.ClassSignature(
    typeParameters,
    parents,
    self,
    declarations
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ClassSignature])
}

@SerialVersionUID(0L)
final case class MethodSignature(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None,
    parameterLists: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.Seq.empty,
    returnType: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.MethodSignature._typemapper_returnType.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Signature.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (typeParameters.isDefined) {
        val __value = typeParameters.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      parameterLists.foreach { __item =>
        val __value = __item
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      
      {
        val __value = dotty.tools.dotc.semanticdb.MethodSignature._typemapper_returnType.toBase(returnType)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      typeParameters.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      parameterLists.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = dotty.tools.dotc.semanticdb.MethodSignature._typemapper_returnType.toBase(returnType)
        if (__v.serializedSize != 0) {
          _output__.writeTag(3, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
    }
    def getTypeParameters: dotty.tools.dotc.semanticdb.Scope = typeParameters.getOrElse(dotty.tools.dotc.semanticdb.Scope.defaultInstance)
    def clearTypeParameters: MethodSignature = copy(typeParameters = _root_.scala.None)
    def withTypeParameters(__v: dotty.tools.dotc.semanticdb.Scope): MethodSignature = copy(typeParameters = Option(__v))
    def clearParameterLists = copy(parameterLists = _root_.scala.Seq.empty)
    def addParameterLists(__vs: dotty.tools.dotc.semanticdb.Scope *): MethodSignature = addAllParameterLists(__vs)
    def addAllParameterLists(__vs: Iterable[dotty.tools.dotc.semanticdb.Scope]): MethodSignature = copy(parameterLists = parameterLists ++ __vs)
    def withParameterLists(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Scope]): MethodSignature = copy(parameterLists = __v)
    def withReturnType(__v: dotty.tools.dotc.semanticdb.Type): MethodSignature = copy(returnType = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.MethodSignature])
}

object MethodSignature  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MethodSignature] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MethodSignature] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.MethodSignature = {
    var __typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    val __parameterLists: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Scope] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Scope]
    var __returnType: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __typeParameters = Option(__typeParameters.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __parameterLists += LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__)
        case 26 =>
          __returnType = _root_.scala.Some(__returnType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.MethodSignature(
        typeParameters = __typeParameters,
        parameterLists = __parameterLists.result(),
        returnType = dotty.tools.dotc.semanticdb.MethodSignature._typemapper_returnType.toCustom(__returnType.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.MethodSignature(
    typeParameters = _root_.scala.None,
    parameterLists = _root_.scala.Seq.empty,
    returnType = dotty.tools.dotc.semanticdb.MethodSignature._typemapper_returnType.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
  )
  final val TYPE_PARAMETERS_FIELD_NUMBER = 1
  final val PARAMETER_LISTS_FIELD_NUMBER = 2
  final val RETURN_TYPE_FIELD_NUMBER = 3
  @transient @sharable
  private[semanticdb] val _typemapper_returnType: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope],
    parameterLists: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Scope],
    returnType: dotty.tools.dotc.semanticdb.Type
  ): _root_.dotty.tools.dotc.semanticdb.MethodSignature = _root_.dotty.tools.dotc.semanticdb.MethodSignature(
    typeParameters,
    parameterLists,
    returnType
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MethodSignature])
}

@SerialVersionUID(0L)
final case class TypeSignature(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None,
    lowerBound: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_lowerBound.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    upperBound: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_upperBound.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Signature.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (typeParameters.isDefined) {
        val __value = typeParameters.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_lowerBound.toBase(lowerBound)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      
      {
        val __value = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_upperBound.toBase(upperBound)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      typeParameters.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_lowerBound.toBase(lowerBound)
        if (__v.serializedSize != 0) {
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      {
        val __v = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_upperBound.toBase(upperBound)
        if (__v.serializedSize != 0) {
          _output__.writeTag(3, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
    }
    def getTypeParameters: dotty.tools.dotc.semanticdb.Scope = typeParameters.getOrElse(dotty.tools.dotc.semanticdb.Scope.defaultInstance)
    def clearTypeParameters: TypeSignature = copy(typeParameters = _root_.scala.None)
    def withTypeParameters(__v: dotty.tools.dotc.semanticdb.Scope): TypeSignature = copy(typeParameters = Option(__v))
    def withLowerBound(__v: dotty.tools.dotc.semanticdb.Type): TypeSignature = copy(lowerBound = __v)
    def withUpperBound(__v: dotty.tools.dotc.semanticdb.Type): TypeSignature = copy(upperBound = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.TypeSignature])
}

object TypeSignature  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeSignature] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeSignature] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.TypeSignature = {
    var __typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    var __lowerBound: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var __upperBound: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __typeParameters = Option(__typeParameters.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __lowerBound = _root_.scala.Some(__lowerBound.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 26 =>
          __upperBound = _root_.scala.Some(__upperBound.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.TypeSignature(
        typeParameters = __typeParameters,
        lowerBound = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_lowerBound.toCustom(__lowerBound.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        upperBound = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_upperBound.toCustom(__upperBound.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.TypeSignature(
    typeParameters = _root_.scala.None,
    lowerBound = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_lowerBound.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    upperBound = dotty.tools.dotc.semanticdb.TypeSignature._typemapper_upperBound.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
  )
  final val TYPE_PARAMETERS_FIELD_NUMBER = 1
  final val LOWER_BOUND_FIELD_NUMBER = 2
  final val UPPER_BOUND_FIELD_NUMBER = 3
  @transient @sharable
  private[semanticdb] val _typemapper_lowerBound: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  @transient @sharable
  private[semanticdb] val _typemapper_upperBound: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope],
    lowerBound: dotty.tools.dotc.semanticdb.Type,
    upperBound: dotty.tools.dotc.semanticdb.Type
  ): _root_.dotty.tools.dotc.semanticdb.TypeSignature = _root_.dotty.tools.dotc.semanticdb.TypeSignature(
    typeParameters,
    lowerBound,
    upperBound
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeSignature])
}

@SerialVersionUID(0L)
final case class ValueSignature(
    tpe: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.ValueSignature._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Signature.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.ValueSignature._typemapper_tpe.toBase(tpe)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.ValueSignature._typemapper_tpe.toBase(tpe)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
    }
    def withTpe(__v: dotty.tools.dotc.semanticdb.Type): ValueSignature = copy(tpe = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.ValueSignature])
}

object ValueSignature  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ValueSignature] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ValueSignature] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.ValueSignature = {
    var __tpe: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __tpe = _root_.scala.Some(__tpe.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.ValueSignature(
        tpe = dotty.tools.dotc.semanticdb.ValueSignature._typemapper_tpe.toCustom(__tpe.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.ValueSignature(
    tpe = dotty.tools.dotc.semanticdb.ValueSignature._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
  )
  final val TPE_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_tpe: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    tpe: dotty.tools.dotc.semanticdb.Type
  ): _root_.dotty.tools.dotc.semanticdb.ValueSignature = _root_.dotty.tools.dotc.semanticdb.ValueSignature(
    tpe
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ValueSignature])
}
