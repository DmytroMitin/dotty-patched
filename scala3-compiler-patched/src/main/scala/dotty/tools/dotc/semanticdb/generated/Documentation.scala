// Generated by https://github.com/tanishiking/semanticdb-for-scala3
// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package dotty.tools.dotc.semanticdb
import dotty.tools.dotc.semanticdb.internal._
import scala.annotation.internal.sharable

@SerialVersionUID(0L)
final case class Documentation(
    message: _root_.scala.Predef.String = "",
    format: dotty.tools.dotc.semanticdb.Documentation.Format = dotty.tools.dotc.semanticdb.Documentation.Format.HTML
    )  extends SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = message
        if (!__value.isEmpty) {
          __size += SemanticdbOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = format.value
        if (__value != 0) {
          __size += SemanticdbOutputStream.computeEnumSize(2, __value)
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = message
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = format.value
        if (__v != 0) {
          _output__.writeEnum(2, __v)
        }
      };
    }
    def withMessage(__v: _root_.scala.Predef.String): Documentation = copy(message = __v)
    def withFormat(__v: dotty.tools.dotc.semanticdb.Documentation.Format): Documentation = copy(format = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.Documentation])
}

object Documentation  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.Documentation] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.Documentation] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.Documentation = {
    var __message: _root_.scala.Predef.String = ""
    var __format: dotty.tools.dotc.semanticdb.Documentation.Format = dotty.tools.dotc.semanticdb.Documentation.Format.HTML
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __message = _input__.readStringRequireUtf8()
        case 16 =>
          __format = dotty.tools.dotc.semanticdb.Documentation.Format.fromValue(_input__.readEnum())
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.Documentation(
        message = __message,
        format = __format
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.Documentation(
    message = "",
    format = dotty.tools.dotc.semanticdb.Documentation.Format.HTML
  )
  sealed abstract class Format(val value: _root_.scala.Int)  extends SemanticdbGeneratedEnum  derives CanEqual {
    type EnumType = Format
    def isHtml: _root_.scala.Boolean = false
    def isMarkdown: _root_.scala.Boolean = false
    def isJavadoc: _root_.scala.Boolean = false
    def isScaladoc: _root_.scala.Boolean = false
    def isKdoc: _root_.scala.Boolean = false
    
    final def asRecognized: _root_.scala.Option[dotty.tools.dotc.semanticdb.Documentation.Format.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[dotty.tools.dotc.semanticdb.Documentation.Format.Recognized])
  }
  
  object Format  {
    sealed trait Recognized extends Format
    
    
    @SerialVersionUID(0L)
    case object HTML extends Format(0) with Format.Recognized {
      val index = 0
      val name = "HTML"
      override def isHtml: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object MARKDOWN extends Format(1) with Format.Recognized {
      val index = 1
      val name = "MARKDOWN"
      override def isMarkdown: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object JAVADOC extends Format(2) with Format.Recognized {
      val index = 2
      val name = "JAVADOC"
      override def isJavadoc: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SCALADOC extends Format(3) with Format.Recognized {
      val index = 3
      val name = "SCALADOC"
      override def isScaladoc: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object KDOC extends Format(4) with Format.Recognized {
      val index = 4
      val name = "KDOC"
      override def isKdoc: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    final case class Unrecognized(unrecognizedValue: _root_.scala.Int)  extends Format(unrecognizedValue) with SemanticdbUnrecognizedEnum
    lazy val values = scala.collection.immutable.Seq(HTML, MARKDOWN, JAVADOC, SCALADOC, KDOC)
    def fromValue(__value: _root_.scala.Int): Format = __value match {
      case 0 => HTML
      case 1 => MARKDOWN
      case 2 => JAVADOC
      case 3 => SCALADOC
      case 4 => KDOC
      case __other => Unrecognized(__other)
    }
    
    
  }
  final val MESSAGE_FIELD_NUMBER = 1
  final val FORMAT_FIELD_NUMBER = 2
  def of(
    message: _root_.scala.Predef.String,
    format: dotty.tools.dotc.semanticdb.Documentation.Format
  ): _root_.dotty.tools.dotc.semanticdb.Documentation = _root_.dotty.tools.dotc.semanticdb.Documentation(
    message,
    format
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.Documentation])
}
