// Generated by https://github.com/tanishiking/semanticdb-for-scala3
// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package dotty.tools.dotc.semanticdb
import dotty.tools.dotc.semanticdb.internal._
import scala.annotation.internal.sharable

sealed trait Type  extends SemanticdbGeneratedSealedOneof  derives CanEqual {
  type MessageType = dotty.tools.dotc.semanticdb.TypeMessage
  final def isEmpty = this.isInstanceOf[dotty.tools.dotc.semanticdb.Type.Empty.type]
  final def isDefined = !isEmpty
  final def asMessage: dotty.tools.dotc.semanticdb.TypeMessage = dotty.tools.dotc.semanticdb.Type.TypeTypeMapper.toBase(this)
  final def asNonEmpty: Option[dotty.tools.dotc.semanticdb.Type.NonEmpty] = if (isEmpty) None else Some(this.asInstanceOf[dotty.tools.dotc.semanticdb.Type.NonEmpty])
}

object Type {
  case object Empty extends dotty.tools.dotc.semanticdb.Type
  
  sealed trait NonEmpty extends dotty.tools.dotc.semanticdb.Type
  def defaultInstance: dotty.tools.dotc.semanticdb.Type = Empty
  
  implicit val TypeTypeMapper: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = new SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] {
    override def toCustom(__base: dotty.tools.dotc.semanticdb.TypeMessage): dotty.tools.dotc.semanticdb.Type = __base.sealedValue match {
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.TypeRef => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SingleType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ThisType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SuperType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ConstantType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.IntersectionType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UnionType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.WithType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.StructuralType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.AnnotatedType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ExistentialType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UniversalType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ByNameType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.RepeatedType => __v.value
      case __v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.MatchType => __v.value
      case dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.Empty => Empty
    }
    override def toBase(__custom: dotty.tools.dotc.semanticdb.Type): dotty.tools.dotc.semanticdb.TypeMessage = dotty.tools.dotc.semanticdb.TypeMessage(__custom match {
      case __v: dotty.tools.dotc.semanticdb.TypeRef => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.TypeRef(__v)
      case __v: dotty.tools.dotc.semanticdb.SingleType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SingleType(__v)
      case __v: dotty.tools.dotc.semanticdb.ThisType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ThisType(__v)
      case __v: dotty.tools.dotc.semanticdb.SuperType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SuperType(__v)
      case __v: dotty.tools.dotc.semanticdb.ConstantType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ConstantType(__v)
      case __v: dotty.tools.dotc.semanticdb.IntersectionType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.IntersectionType(__v)
      case __v: dotty.tools.dotc.semanticdb.UnionType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UnionType(__v)
      case __v: dotty.tools.dotc.semanticdb.WithType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.WithType(__v)
      case __v: dotty.tools.dotc.semanticdb.StructuralType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.StructuralType(__v)
      case __v: dotty.tools.dotc.semanticdb.AnnotatedType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.AnnotatedType(__v)
      case __v: dotty.tools.dotc.semanticdb.ExistentialType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ExistentialType(__v)
      case __v: dotty.tools.dotc.semanticdb.UniversalType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UniversalType(__v)
      case __v: dotty.tools.dotc.semanticdb.ByNameType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ByNameType(__v)
      case __v: dotty.tools.dotc.semanticdb.RepeatedType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.RepeatedType(__v)
      case __v: dotty.tools.dotc.semanticdb.MatchType => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.MatchType(__v)
      case Empty => dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.Empty
    })
  }
}
@SerialVersionUID(0L)
final case class TypeMessage(
    sealedValue: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.Empty
    )  extends SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (sealedValue.typeRef.isDefined) {
        val __value = sealedValue.typeRef.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.singleType.isDefined) {
        val __value = sealedValue.singleType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.thisType.isDefined) {
        val __value = sealedValue.thisType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.superType.isDefined) {
        val __value = sealedValue.superType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.constantType.isDefined) {
        val __value = sealedValue.constantType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.intersectionType.isDefined) {
        val __value = sealedValue.intersectionType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.unionType.isDefined) {
        val __value = sealedValue.unionType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.withType.isDefined) {
        val __value = sealedValue.withType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.structuralType.isDefined) {
        val __value = sealedValue.structuralType.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.annotatedType.isDefined) {
        val __value = sealedValue.annotatedType.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.existentialType.isDefined) {
        val __value = sealedValue.existentialType.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.universalType.isDefined) {
        val __value = sealedValue.universalType.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.byNameType.isDefined) {
        val __value = sealedValue.byNameType.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.repeatedType.isDefined) {
        val __value = sealedValue.repeatedType.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (sealedValue.matchType.isDefined) {
        val __value = sealedValue.matchType.get
        __size += 2 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      sealedValue.typeRef.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.structuralType.foreach { __v =>
        val __m = __v
        _output__.writeTag(7, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.annotatedType.foreach { __v =>
        val __m = __v
        _output__.writeTag(8, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.existentialType.foreach { __v =>
        val __m = __v
        _output__.writeTag(9, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.universalType.foreach { __v =>
        val __m = __v
        _output__.writeTag(10, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.byNameType.foreach { __v =>
        val __m = __v
        _output__.writeTag(13, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.repeatedType.foreach { __v =>
        val __m = __v
        _output__.writeTag(14, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.intersectionType.foreach { __v =>
        val __m = __v
        _output__.writeTag(17, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.unionType.foreach { __v =>
        val __m = __v
        _output__.writeTag(18, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.withType.foreach { __v =>
        val __m = __v
        _output__.writeTag(19, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.singleType.foreach { __v =>
        val __m = __v
        _output__.writeTag(20, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.thisType.foreach { __v =>
        val __m = __v
        _output__.writeTag(21, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.superType.foreach { __v =>
        val __m = __v
        _output__.writeTag(22, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.constantType.foreach { __v =>
        val __m = __v
        _output__.writeTag(23, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      sealedValue.matchType.foreach { __v =>
        val __m = __v
        _output__.writeTag(25, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def getTypeRef: dotty.tools.dotc.semanticdb.TypeRef = sealedValue.typeRef.getOrElse(dotty.tools.dotc.semanticdb.TypeRef.defaultInstance)
    def withTypeRef(__v: dotty.tools.dotc.semanticdb.TypeRef): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.TypeRef(__v))
    def getSingleType: dotty.tools.dotc.semanticdb.SingleType = sealedValue.singleType.getOrElse(dotty.tools.dotc.semanticdb.SingleType.defaultInstance)
    def withSingleType(__v: dotty.tools.dotc.semanticdb.SingleType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SingleType(__v))
    def getThisType: dotty.tools.dotc.semanticdb.ThisType = sealedValue.thisType.getOrElse(dotty.tools.dotc.semanticdb.ThisType.defaultInstance)
    def withThisType(__v: dotty.tools.dotc.semanticdb.ThisType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ThisType(__v))
    def getSuperType: dotty.tools.dotc.semanticdb.SuperType = sealedValue.superType.getOrElse(dotty.tools.dotc.semanticdb.SuperType.defaultInstance)
    def withSuperType(__v: dotty.tools.dotc.semanticdb.SuperType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SuperType(__v))
    def getConstantType: dotty.tools.dotc.semanticdb.ConstantType = sealedValue.constantType.getOrElse(dotty.tools.dotc.semanticdb.ConstantType.defaultInstance)
    def withConstantType(__v: dotty.tools.dotc.semanticdb.ConstantType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ConstantType(__v))
    def getIntersectionType: dotty.tools.dotc.semanticdb.IntersectionType = sealedValue.intersectionType.getOrElse(dotty.tools.dotc.semanticdb.IntersectionType.defaultInstance)
    def withIntersectionType(__v: dotty.tools.dotc.semanticdb.IntersectionType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.IntersectionType(__v))
    def getUnionType: dotty.tools.dotc.semanticdb.UnionType = sealedValue.unionType.getOrElse(dotty.tools.dotc.semanticdb.UnionType.defaultInstance)
    def withUnionType(__v: dotty.tools.dotc.semanticdb.UnionType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UnionType(__v))
    def getWithType: dotty.tools.dotc.semanticdb.WithType = sealedValue.withType.getOrElse(dotty.tools.dotc.semanticdb.WithType.defaultInstance)
    def withWithType(__v: dotty.tools.dotc.semanticdb.WithType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.WithType(__v))
    def getStructuralType: dotty.tools.dotc.semanticdb.StructuralType = sealedValue.structuralType.getOrElse(dotty.tools.dotc.semanticdb.StructuralType.defaultInstance)
    def withStructuralType(__v: dotty.tools.dotc.semanticdb.StructuralType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.StructuralType(__v))
    def getAnnotatedType: dotty.tools.dotc.semanticdb.AnnotatedType = sealedValue.annotatedType.getOrElse(dotty.tools.dotc.semanticdb.AnnotatedType.defaultInstance)
    def withAnnotatedType(__v: dotty.tools.dotc.semanticdb.AnnotatedType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.AnnotatedType(__v))
    def getExistentialType: dotty.tools.dotc.semanticdb.ExistentialType = sealedValue.existentialType.getOrElse(dotty.tools.dotc.semanticdb.ExistentialType.defaultInstance)
    def withExistentialType(__v: dotty.tools.dotc.semanticdb.ExistentialType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ExistentialType(__v))
    def getUniversalType: dotty.tools.dotc.semanticdb.UniversalType = sealedValue.universalType.getOrElse(dotty.tools.dotc.semanticdb.UniversalType.defaultInstance)
    def withUniversalType(__v: dotty.tools.dotc.semanticdb.UniversalType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UniversalType(__v))
    def getByNameType: dotty.tools.dotc.semanticdb.ByNameType = sealedValue.byNameType.getOrElse(dotty.tools.dotc.semanticdb.ByNameType.defaultInstance)
    def withByNameType(__v: dotty.tools.dotc.semanticdb.ByNameType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ByNameType(__v))
    def getRepeatedType: dotty.tools.dotc.semanticdb.RepeatedType = sealedValue.repeatedType.getOrElse(dotty.tools.dotc.semanticdb.RepeatedType.defaultInstance)
    def withRepeatedType(__v: dotty.tools.dotc.semanticdb.RepeatedType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.RepeatedType(__v))
    def getMatchType: dotty.tools.dotc.semanticdb.MatchType = sealedValue.matchType.getOrElse(dotty.tools.dotc.semanticdb.MatchType.defaultInstance)
    def withMatchType(__v: dotty.tools.dotc.semanticdb.MatchType): TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.MatchType(__v))
    def clearSealedValue: TypeMessage = copy(sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.Empty)
    def withSealedValue(__v: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue): TypeMessage = copy(sealedValue = __v)
    
    
    
    
    def toType: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.Type.TypeTypeMapper.toCustom(this)
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.Type])
}

object TypeMessage  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeMessage] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeMessage] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.TypeMessage = {
    var __sealedValue: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.Empty
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 18 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.TypeRef(__sealedValue.typeRef.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeRef](_input__))(LiteParser.readMessage(_input__, _)))
        case 162 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SingleType(__sealedValue.singleType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.SingleType](_input__))(LiteParser.readMessage(_input__, _)))
        case 170 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ThisType(__sealedValue.thisType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.ThisType](_input__))(LiteParser.readMessage(_input__, _)))
        case 178 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.SuperType(__sealedValue.superType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.SuperType](_input__))(LiteParser.readMessage(_input__, _)))
        case 186 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ConstantType(__sealedValue.constantType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.ConstantType](_input__))(LiteParser.readMessage(_input__, _)))
        case 138 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.IntersectionType(__sealedValue.intersectionType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.IntersectionType](_input__))(LiteParser.readMessage(_input__, _)))
        case 146 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UnionType(__sealedValue.unionType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.UnionType](_input__))(LiteParser.readMessage(_input__, _)))
        case 154 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.WithType(__sealedValue.withType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.WithType](_input__))(LiteParser.readMessage(_input__, _)))
        case 58 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.StructuralType(__sealedValue.structuralType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.StructuralType](_input__))(LiteParser.readMessage(_input__, _)))
        case 66 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.AnnotatedType(__sealedValue.annotatedType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.AnnotatedType](_input__))(LiteParser.readMessage(_input__, _)))
        case 74 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ExistentialType(__sealedValue.existentialType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.ExistentialType](_input__))(LiteParser.readMessage(_input__, _)))
        case 82 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.UniversalType(__sealedValue.universalType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.UniversalType](_input__))(LiteParser.readMessage(_input__, _)))
        case 106 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.ByNameType(__sealedValue.byNameType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.ByNameType](_input__))(LiteParser.readMessage(_input__, _)))
        case 114 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.RepeatedType(__sealedValue.repeatedType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.RepeatedType](_input__))(LiteParser.readMessage(_input__, _)))
        case 202 =>
          __sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.MatchType(__sealedValue.matchType.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.MatchType](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.TypeMessage(
        sealedValue = __sealedValue
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.TypeMessage(
    sealedValue = dotty.tools.dotc.semanticdb.TypeMessage.SealedValue.Empty
  )
  sealed trait SealedValue  extends SemanticdbGeneratedOneof  derives CanEqual {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isTypeRef: _root_.scala.Boolean = false
    def isSingleType: _root_.scala.Boolean = false
    def isThisType: _root_.scala.Boolean = false
    def isSuperType: _root_.scala.Boolean = false
    def isConstantType: _root_.scala.Boolean = false
    def isIntersectionType: _root_.scala.Boolean = false
    def isUnionType: _root_.scala.Boolean = false
    def isWithType: _root_.scala.Boolean = false
    def isStructuralType: _root_.scala.Boolean = false
    def isAnnotatedType: _root_.scala.Boolean = false
    def isExistentialType: _root_.scala.Boolean = false
    def isUniversalType: _root_.scala.Boolean = false
    def isByNameType: _root_.scala.Boolean = false
    def isRepeatedType: _root_.scala.Boolean = false
    def isMatchType: _root_.scala.Boolean = false
    def typeRef: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeRef] = _root_.scala.None
    def singleType: _root_.scala.Option[dotty.tools.dotc.semanticdb.SingleType] = _root_.scala.None
    def thisType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ThisType] = _root_.scala.None
    def superType: _root_.scala.Option[dotty.tools.dotc.semanticdb.SuperType] = _root_.scala.None
    def constantType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ConstantType] = _root_.scala.None
    def intersectionType: _root_.scala.Option[dotty.tools.dotc.semanticdb.IntersectionType] = _root_.scala.None
    def unionType: _root_.scala.Option[dotty.tools.dotc.semanticdb.UnionType] = _root_.scala.None
    def withType: _root_.scala.Option[dotty.tools.dotc.semanticdb.WithType] = _root_.scala.None
    def structuralType: _root_.scala.Option[dotty.tools.dotc.semanticdb.StructuralType] = _root_.scala.None
    def annotatedType: _root_.scala.Option[dotty.tools.dotc.semanticdb.AnnotatedType] = _root_.scala.None
    def existentialType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ExistentialType] = _root_.scala.None
    def universalType: _root_.scala.Option[dotty.tools.dotc.semanticdb.UniversalType] = _root_.scala.None
    def byNameType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ByNameType] = _root_.scala.None
    def repeatedType: _root_.scala.Option[dotty.tools.dotc.semanticdb.RepeatedType] = _root_.scala.None
    def matchType: _root_.scala.Option[dotty.tools.dotc.semanticdb.MatchType] = _root_.scala.None
  }
  object SealedValue {
    @SerialVersionUID(0L)
    case object Empty extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class TypeRef(value: dotty.tools.dotc.semanticdb.TypeRef) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.TypeRef
      override def isTypeRef: _root_.scala.Boolean = true
      override def typeRef: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeRef] = Some(value)
      override def number: _root_.scala.Int = 2
    }
    @SerialVersionUID(0L)
    final case class SingleType(value: dotty.tools.dotc.semanticdb.SingleType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.SingleType
      override def isSingleType: _root_.scala.Boolean = true
      override def singleType: _root_.scala.Option[dotty.tools.dotc.semanticdb.SingleType] = Some(value)
      override def number: _root_.scala.Int = 20
    }
    @SerialVersionUID(0L)
    final case class ThisType(value: dotty.tools.dotc.semanticdb.ThisType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.ThisType
      override def isThisType: _root_.scala.Boolean = true
      override def thisType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ThisType] = Some(value)
      override def number: _root_.scala.Int = 21
    }
    @SerialVersionUID(0L)
    final case class SuperType(value: dotty.tools.dotc.semanticdb.SuperType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.SuperType
      override def isSuperType: _root_.scala.Boolean = true
      override def superType: _root_.scala.Option[dotty.tools.dotc.semanticdb.SuperType] = Some(value)
      override def number: _root_.scala.Int = 22
    }
    @SerialVersionUID(0L)
    final case class ConstantType(value: dotty.tools.dotc.semanticdb.ConstantType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.ConstantType
      override def isConstantType: _root_.scala.Boolean = true
      override def constantType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ConstantType] = Some(value)
      override def number: _root_.scala.Int = 23
    }
    @SerialVersionUID(0L)
    final case class IntersectionType(value: dotty.tools.dotc.semanticdb.IntersectionType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.IntersectionType
      override def isIntersectionType: _root_.scala.Boolean = true
      override def intersectionType: _root_.scala.Option[dotty.tools.dotc.semanticdb.IntersectionType] = Some(value)
      override def number: _root_.scala.Int = 17
    }
    @SerialVersionUID(0L)
    final case class UnionType(value: dotty.tools.dotc.semanticdb.UnionType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.UnionType
      override def isUnionType: _root_.scala.Boolean = true
      override def unionType: _root_.scala.Option[dotty.tools.dotc.semanticdb.UnionType] = Some(value)
      override def number: _root_.scala.Int = 18
    }
    @SerialVersionUID(0L)
    final case class WithType(value: dotty.tools.dotc.semanticdb.WithType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.WithType
      override def isWithType: _root_.scala.Boolean = true
      override def withType: _root_.scala.Option[dotty.tools.dotc.semanticdb.WithType] = Some(value)
      override def number: _root_.scala.Int = 19
    }
    @SerialVersionUID(0L)
    final case class StructuralType(value: dotty.tools.dotc.semanticdb.StructuralType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.StructuralType
      override def isStructuralType: _root_.scala.Boolean = true
      override def structuralType: _root_.scala.Option[dotty.tools.dotc.semanticdb.StructuralType] = Some(value)
      override def number: _root_.scala.Int = 7
    }
    @SerialVersionUID(0L)
    final case class AnnotatedType(value: dotty.tools.dotc.semanticdb.AnnotatedType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.AnnotatedType
      override def isAnnotatedType: _root_.scala.Boolean = true
      override def annotatedType: _root_.scala.Option[dotty.tools.dotc.semanticdb.AnnotatedType] = Some(value)
      override def number: _root_.scala.Int = 8
    }
    @SerialVersionUID(0L)
    final case class ExistentialType(value: dotty.tools.dotc.semanticdb.ExistentialType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.ExistentialType
      override def isExistentialType: _root_.scala.Boolean = true
      override def existentialType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ExistentialType] = Some(value)
      override def number: _root_.scala.Int = 9
    }
    @SerialVersionUID(0L)
    final case class UniversalType(value: dotty.tools.dotc.semanticdb.UniversalType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.UniversalType
      override def isUniversalType: _root_.scala.Boolean = true
      override def universalType: _root_.scala.Option[dotty.tools.dotc.semanticdb.UniversalType] = Some(value)
      override def number: _root_.scala.Int = 10
    }
    @SerialVersionUID(0L)
    final case class ByNameType(value: dotty.tools.dotc.semanticdb.ByNameType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.ByNameType
      override def isByNameType: _root_.scala.Boolean = true
      override def byNameType: _root_.scala.Option[dotty.tools.dotc.semanticdb.ByNameType] = Some(value)
      override def number: _root_.scala.Int = 13
    }
    @SerialVersionUID(0L)
    final case class RepeatedType(value: dotty.tools.dotc.semanticdb.RepeatedType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.RepeatedType
      override def isRepeatedType: _root_.scala.Boolean = true
      override def repeatedType: _root_.scala.Option[dotty.tools.dotc.semanticdb.RepeatedType] = Some(value)
      override def number: _root_.scala.Int = 14
    }
    @SerialVersionUID(0L)
    final case class MatchType(value: dotty.tools.dotc.semanticdb.MatchType) extends dotty.tools.dotc.semanticdb.TypeMessage.SealedValue  derives CanEqual {
      type ValueType = dotty.tools.dotc.semanticdb.MatchType
      override def isMatchType: _root_.scala.Boolean = true
      override def matchType: _root_.scala.Option[dotty.tools.dotc.semanticdb.MatchType] = Some(value)
      override def number: _root_.scala.Int = 25
    }
  }
  final val TYPE_REF_FIELD_NUMBER = 2
  final val SINGLE_TYPE_FIELD_NUMBER = 20
  final val THIS_TYPE_FIELD_NUMBER = 21
  final val SUPER_TYPE_FIELD_NUMBER = 22
  final val CONSTANT_TYPE_FIELD_NUMBER = 23
  final val INTERSECTION_TYPE_FIELD_NUMBER = 17
  final val UNION_TYPE_FIELD_NUMBER = 18
  final val WITH_TYPE_FIELD_NUMBER = 19
  final val STRUCTURAL_TYPE_FIELD_NUMBER = 7
  final val ANNOTATED_TYPE_FIELD_NUMBER = 8
  final val EXISTENTIAL_TYPE_FIELD_NUMBER = 9
  final val UNIVERSAL_TYPE_FIELD_NUMBER = 10
  final val BY_NAME_TYPE_FIELD_NUMBER = 13
  final val REPEATED_TYPE_FIELD_NUMBER = 14
  final val MATCH_TYPE_FIELD_NUMBER = 25
  def of(
    sealedValue: dotty.tools.dotc.semanticdb.TypeMessage.SealedValue
  ): _root_.dotty.tools.dotc.semanticdb.TypeMessage = _root_.dotty.tools.dotc.semanticdb.TypeMessage(
    sealedValue
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.Type])
}

@SerialVersionUID(0L)
final case class TypeRef(
    prefix: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.TypeRef._typemapper_prefix.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    symbol: _root_.scala.Predef.String = "",
    typeArguments: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type] = _root_.scala.Seq.empty
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.TypeRef._typemapper_prefix.toBase(prefix)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      
      {
        val __value = symbol
        if (!__value.isEmpty) {
          __size += SemanticdbOutputStream.computeStringSize(2, __value)
        }
      };
      typeArguments.foreach { __item =>
        val __value = dotty.tools.dotc.semanticdb.TypeRef._typemapper_typeArguments.toBase(__item)
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.TypeRef._typemapper_prefix.toBase(prefix)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      {
        val __v = symbol
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      typeArguments.foreach { __v =>
        val __m = dotty.tools.dotc.semanticdb.TypeRef._typemapper_typeArguments.toBase(__v)
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def withPrefix(__v: dotty.tools.dotc.semanticdb.Type): TypeRef = copy(prefix = __v)
    def withSymbol(__v: _root_.scala.Predef.String): TypeRef = copy(symbol = __v)
    def clearTypeArguments = copy(typeArguments = _root_.scala.Seq.empty)
    def addTypeArguments(__vs: dotty.tools.dotc.semanticdb.Type *): TypeRef = addAllTypeArguments(__vs)
    def addAllTypeArguments(__vs: Iterable[dotty.tools.dotc.semanticdb.Type]): TypeRef = copy(typeArguments = typeArguments ++ __vs)
    def withTypeArguments(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]): TypeRef = copy(typeArguments = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.TypeRef])
}

object TypeRef  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeRef] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeRef] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.TypeRef = {
    var __prefix: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var __symbol: _root_.scala.Predef.String = ""
    val __typeArguments: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type]
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __prefix = _root_.scala.Some(__prefix.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __symbol = _input__.readStringRequireUtf8()
        case 26 =>
          __typeArguments += dotty.tools.dotc.semanticdb.TypeRef._typemapper_typeArguments.toCustom(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.TypeRef(
        prefix = dotty.tools.dotc.semanticdb.TypeRef._typemapper_prefix.toCustom(__prefix.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        symbol = __symbol,
        typeArguments = __typeArguments.result()
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.TypeRef(
    prefix = dotty.tools.dotc.semanticdb.TypeRef._typemapper_prefix.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    symbol = "",
    typeArguments = _root_.scala.Seq.empty
  )
  final val PREFIX_FIELD_NUMBER = 1
  final val SYMBOL_FIELD_NUMBER = 2
  final val TYPE_ARGUMENTS_FIELD_NUMBER = 3
  @transient @sharable
  private[semanticdb] val _typemapper_prefix: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  @transient @sharable
  private[semanticdb] val _typemapper_typeArguments: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    prefix: dotty.tools.dotc.semanticdb.Type,
    symbol: _root_.scala.Predef.String,
    typeArguments: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]
  ): _root_.dotty.tools.dotc.semanticdb.TypeRef = _root_.dotty.tools.dotc.semanticdb.TypeRef(
    prefix,
    symbol,
    typeArguments
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.TypeRef])
}

@SerialVersionUID(0L)
final case class SingleType(
    prefix: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.SingleType._typemapper_prefix.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    symbol: _root_.scala.Predef.String = ""
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.SingleType._typemapper_prefix.toBase(prefix)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      
      {
        val __value = symbol
        if (!__value.isEmpty) {
          __size += SemanticdbOutputStream.computeStringSize(2, __value)
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.SingleType._typemapper_prefix.toBase(prefix)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      {
        val __v = symbol
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
    }
    def withPrefix(__v: dotty.tools.dotc.semanticdb.Type): SingleType = copy(prefix = __v)
    def withSymbol(__v: _root_.scala.Predef.String): SingleType = copy(symbol = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.SingleType])
}

object SingleType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SingleType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SingleType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.SingleType = {
    var __prefix: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var __symbol: _root_.scala.Predef.String = ""
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __prefix = _root_.scala.Some(__prefix.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __symbol = _input__.readStringRequireUtf8()
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.SingleType(
        prefix = dotty.tools.dotc.semanticdb.SingleType._typemapper_prefix.toCustom(__prefix.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        symbol = __symbol
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.SingleType(
    prefix = dotty.tools.dotc.semanticdb.SingleType._typemapper_prefix.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    symbol = ""
  )
  final val PREFIX_FIELD_NUMBER = 1
  final val SYMBOL_FIELD_NUMBER = 2
  @transient @sharable
  private[semanticdb] val _typemapper_prefix: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    prefix: dotty.tools.dotc.semanticdb.Type,
    symbol: _root_.scala.Predef.String
  ): _root_.dotty.tools.dotc.semanticdb.SingleType = _root_.dotty.tools.dotc.semanticdb.SingleType(
    prefix,
    symbol
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SingleType])
}

@SerialVersionUID(0L)
final case class ThisType(
    symbol: _root_.scala.Predef.String = ""
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = symbol
        if (!__value.isEmpty) {
          __size += SemanticdbOutputStream.computeStringSize(1, __value)
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = symbol
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
    }
    def withSymbol(__v: _root_.scala.Predef.String): ThisType = copy(symbol = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.ThisType])
}

object ThisType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ThisType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ThisType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.ThisType = {
    var __symbol: _root_.scala.Predef.String = ""
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __symbol = _input__.readStringRequireUtf8()
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.ThisType(
        symbol = __symbol
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.ThisType(
    symbol = ""
  )
  final val SYMBOL_FIELD_NUMBER = 1
  def of(
    symbol: _root_.scala.Predef.String
  ): _root_.dotty.tools.dotc.semanticdb.ThisType = _root_.dotty.tools.dotc.semanticdb.ThisType(
    symbol
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ThisType])
}

@SerialVersionUID(0L)
final case class SuperType(
    prefix: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.SuperType._typemapper_prefix.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    symbol: _root_.scala.Predef.String = ""
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.SuperType._typemapper_prefix.toBase(prefix)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      
      {
        val __value = symbol
        if (!__value.isEmpty) {
          __size += SemanticdbOutputStream.computeStringSize(2, __value)
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.SuperType._typemapper_prefix.toBase(prefix)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      {
        val __v = symbol
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
    }
    def withPrefix(__v: dotty.tools.dotc.semanticdb.Type): SuperType = copy(prefix = __v)
    def withSymbol(__v: _root_.scala.Predef.String): SuperType = copy(symbol = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.SuperType])
}

object SuperType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SuperType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SuperType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.SuperType = {
    var __prefix: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var __symbol: _root_.scala.Predef.String = ""
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __prefix = _root_.scala.Some(__prefix.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __symbol = _input__.readStringRequireUtf8()
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.SuperType(
        prefix = dotty.tools.dotc.semanticdb.SuperType._typemapper_prefix.toCustom(__prefix.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        symbol = __symbol
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.SuperType(
    prefix = dotty.tools.dotc.semanticdb.SuperType._typemapper_prefix.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    symbol = ""
  )
  final val PREFIX_FIELD_NUMBER = 1
  final val SYMBOL_FIELD_NUMBER = 2
  @transient @sharable
  private[semanticdb] val _typemapper_prefix: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    prefix: dotty.tools.dotc.semanticdb.Type,
    symbol: _root_.scala.Predef.String
  ): _root_.dotty.tools.dotc.semanticdb.SuperType = _root_.dotty.tools.dotc.semanticdb.SuperType(
    prefix,
    symbol
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.SuperType])
}

@SerialVersionUID(0L)
final case class ConstantType(
    constant: dotty.tools.dotc.semanticdb.Constant = dotty.tools.dotc.semanticdb.ConstantType._typemapper_constant.toCustom(dotty.tools.dotc.semanticdb.ConstantMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.ConstantType._typemapper_constant.toBase(constant)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.ConstantType._typemapper_constant.toBase(constant)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
    }
    def withConstant(__v: dotty.tools.dotc.semanticdb.Constant): ConstantType = copy(constant = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.ConstantType])
}

object ConstantType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ConstantType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ConstantType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.ConstantType = {
    var __constant: _root_.scala.Option[dotty.tools.dotc.semanticdb.ConstantMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __constant = _root_.scala.Some(__constant.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.ConstantMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.ConstantType(
        constant = dotty.tools.dotc.semanticdb.ConstantType._typemapper_constant.toCustom(__constant.getOrElse(dotty.tools.dotc.semanticdb.ConstantMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.ConstantType(
    constant = dotty.tools.dotc.semanticdb.ConstantType._typemapper_constant.toCustom(dotty.tools.dotc.semanticdb.ConstantMessage.defaultInstance)
  )
  final val CONSTANT_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_constant: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.ConstantMessage, dotty.tools.dotc.semanticdb.Constant] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.ConstantMessage, dotty.tools.dotc.semanticdb.Constant]]
  def of(
    constant: dotty.tools.dotc.semanticdb.Constant
  ): _root_.dotty.tools.dotc.semanticdb.ConstantType = _root_.dotty.tools.dotc.semanticdb.ConstantType(
    constant
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ConstantType])
}

@SerialVersionUID(0L)
final case class IntersectionType(
    types: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type] = _root_.scala.Seq.empty
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      types.foreach { __item =>
        val __value = dotty.tools.dotc.semanticdb.IntersectionType._typemapper_types.toBase(__item)
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      types.foreach { __v =>
        val __m = dotty.tools.dotc.semanticdb.IntersectionType._typemapper_types.toBase(__v)
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def clearTypes = copy(types = _root_.scala.Seq.empty)
    def addTypes(__vs: dotty.tools.dotc.semanticdb.Type *): IntersectionType = addAllTypes(__vs)
    def addAllTypes(__vs: Iterable[dotty.tools.dotc.semanticdb.Type]): IntersectionType = copy(types = types ++ __vs)
    def withTypes(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]): IntersectionType = copy(types = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.IntersectionType])
}

object IntersectionType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.IntersectionType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.IntersectionType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.IntersectionType = {
    val __types: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type]
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __types += dotty.tools.dotc.semanticdb.IntersectionType._typemapper_types.toCustom(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.IntersectionType(
        types = __types.result()
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.IntersectionType(
    types = _root_.scala.Seq.empty
  )
  final val TYPES_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_types: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    types: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]
  ): _root_.dotty.tools.dotc.semanticdb.IntersectionType = _root_.dotty.tools.dotc.semanticdb.IntersectionType(
    types
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.IntersectionType])
}

@SerialVersionUID(0L)
final case class UnionType(
    types: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type] = _root_.scala.Seq.empty
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      types.foreach { __item =>
        val __value = dotty.tools.dotc.semanticdb.UnionType._typemapper_types.toBase(__item)
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      types.foreach { __v =>
        val __m = dotty.tools.dotc.semanticdb.UnionType._typemapper_types.toBase(__v)
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def clearTypes = copy(types = _root_.scala.Seq.empty)
    def addTypes(__vs: dotty.tools.dotc.semanticdb.Type *): UnionType = addAllTypes(__vs)
    def addAllTypes(__vs: Iterable[dotty.tools.dotc.semanticdb.Type]): UnionType = copy(types = types ++ __vs)
    def withTypes(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]): UnionType = copy(types = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.UnionType])
}

object UnionType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.UnionType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.UnionType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.UnionType = {
    val __types: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type]
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __types += dotty.tools.dotc.semanticdb.UnionType._typemapper_types.toCustom(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.UnionType(
        types = __types.result()
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.UnionType(
    types = _root_.scala.Seq.empty
  )
  final val TYPES_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_types: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    types: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]
  ): _root_.dotty.tools.dotc.semanticdb.UnionType = _root_.dotty.tools.dotc.semanticdb.UnionType(
    types
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.UnionType])
}

@SerialVersionUID(0L)
final case class WithType(
    types: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type] = _root_.scala.Seq.empty
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      types.foreach { __item =>
        val __value = dotty.tools.dotc.semanticdb.WithType._typemapper_types.toBase(__item)
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      types.foreach { __v =>
        val __m = dotty.tools.dotc.semanticdb.WithType._typemapper_types.toBase(__v)
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def clearTypes = copy(types = _root_.scala.Seq.empty)
    def addTypes(__vs: dotty.tools.dotc.semanticdb.Type *): WithType = addAllTypes(__vs)
    def addAllTypes(__vs: Iterable[dotty.tools.dotc.semanticdb.Type]): WithType = copy(types = types ++ __vs)
    def withTypes(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]): WithType = copy(types = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.WithType])
}

object WithType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.WithType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.WithType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.WithType = {
    val __types: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Type]
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __types += dotty.tools.dotc.semanticdb.WithType._typemapper_types.toCustom(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.WithType(
        types = __types.result()
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.WithType(
    types = _root_.scala.Seq.empty
  )
  final val TYPES_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_types: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    types: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Type]
  ): _root_.dotty.tools.dotc.semanticdb.WithType = _root_.dotty.tools.dotc.semanticdb.WithType(
    types
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.WithType])
}

@SerialVersionUID(0L)
final case class StructuralType(
    tpe: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.StructuralType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.StructuralType._typemapper_tpe.toBase(tpe)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      if (declarations.isDefined) {
        val __value = declarations.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.StructuralType._typemapper_tpe.toBase(tpe)
        if (__v.serializedSize != 0) {
          _output__.writeTag(4, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      declarations.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def withTpe(__v: dotty.tools.dotc.semanticdb.Type): StructuralType = copy(tpe = __v)
    def getDeclarations: dotty.tools.dotc.semanticdb.Scope = declarations.getOrElse(dotty.tools.dotc.semanticdb.Scope.defaultInstance)
    def clearDeclarations: StructuralType = copy(declarations = _root_.scala.None)
    def withDeclarations(__v: dotty.tools.dotc.semanticdb.Scope): StructuralType = copy(declarations = Option(__v))
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.StructuralType])
}

object StructuralType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.StructuralType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.StructuralType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.StructuralType = {
    var __tpe: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var __declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 34 =>
          __tpe = _root_.scala.Some(__tpe.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 42 =>
          __declarations = Option(__declarations.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.StructuralType(
        tpe = dotty.tools.dotc.semanticdb.StructuralType._typemapper_tpe.toCustom(__tpe.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        declarations = __declarations
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.StructuralType(
    tpe = dotty.tools.dotc.semanticdb.StructuralType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    declarations = _root_.scala.None
  )
  final val TPE_FIELD_NUMBER = 4
  final val DECLARATIONS_FIELD_NUMBER = 5
  @transient @sharable
  private[semanticdb] val _typemapper_tpe: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    tpe: dotty.tools.dotc.semanticdb.Type,
    declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope]
  ): _root_.dotty.tools.dotc.semanticdb.StructuralType = _root_.dotty.tools.dotc.semanticdb.StructuralType(
    tpe,
    declarations
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.StructuralType])
}

@SerialVersionUID(0L)
final case class AnnotatedType(
    annotations: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Annotation] = _root_.scala.Seq.empty,
    tpe: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.AnnotatedType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      annotations.foreach { __item =>
        val __value = __item
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      
      {
        val __value = dotty.tools.dotc.semanticdb.AnnotatedType._typemapper_tpe.toBase(tpe)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.AnnotatedType._typemapper_tpe.toBase(tpe)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      annotations.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def clearAnnotations = copy(annotations = _root_.scala.Seq.empty)
    def addAnnotations(__vs: dotty.tools.dotc.semanticdb.Annotation *): AnnotatedType = addAllAnnotations(__vs)
    def addAllAnnotations(__vs: Iterable[dotty.tools.dotc.semanticdb.Annotation]): AnnotatedType = copy(annotations = annotations ++ __vs)
    def withAnnotations(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Annotation]): AnnotatedType = copy(annotations = __v)
    def withTpe(__v: dotty.tools.dotc.semanticdb.Type): AnnotatedType = copy(tpe = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.AnnotatedType])
}

object AnnotatedType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.AnnotatedType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.AnnotatedType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.AnnotatedType = {
    val __annotations: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Annotation] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.Annotation]
    var __tpe: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 26 =>
          __annotations += LiteParser.readMessage[dotty.tools.dotc.semanticdb.Annotation](_input__)
        case 10 =>
          __tpe = _root_.scala.Some(__tpe.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.AnnotatedType(
        annotations = __annotations.result(),
        tpe = dotty.tools.dotc.semanticdb.AnnotatedType._typemapper_tpe.toCustom(__tpe.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.AnnotatedType(
    annotations = _root_.scala.Seq.empty,
    tpe = dotty.tools.dotc.semanticdb.AnnotatedType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
  )
  final val ANNOTATIONS_FIELD_NUMBER = 3
  final val TPE_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_tpe: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    annotations: _root_.scala.Seq[dotty.tools.dotc.semanticdb.Annotation],
    tpe: dotty.tools.dotc.semanticdb.Type
  ): _root_.dotty.tools.dotc.semanticdb.AnnotatedType = _root_.dotty.tools.dotc.semanticdb.AnnotatedType(
    annotations,
    tpe
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.AnnotatedType])
}

@SerialVersionUID(0L)
final case class ExistentialType(
    tpe: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.ExistentialType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.ExistentialType._typemapper_tpe.toBase(tpe)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      if (declarations.isDefined) {
        val __value = declarations.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.ExistentialType._typemapper_tpe.toBase(tpe)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      declarations.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def withTpe(__v: dotty.tools.dotc.semanticdb.Type): ExistentialType = copy(tpe = __v)
    def getDeclarations: dotty.tools.dotc.semanticdb.Scope = declarations.getOrElse(dotty.tools.dotc.semanticdb.Scope.defaultInstance)
    def clearDeclarations: ExistentialType = copy(declarations = _root_.scala.None)
    def withDeclarations(__v: dotty.tools.dotc.semanticdb.Scope): ExistentialType = copy(declarations = Option(__v))
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.ExistentialType])
}

object ExistentialType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ExistentialType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ExistentialType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.ExistentialType = {
    var __tpe: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var __declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __tpe = _root_.scala.Some(__tpe.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 26 =>
          __declarations = Option(__declarations.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.ExistentialType(
        tpe = dotty.tools.dotc.semanticdb.ExistentialType._typemapper_tpe.toCustom(__tpe.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        declarations = __declarations
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.ExistentialType(
    tpe = dotty.tools.dotc.semanticdb.ExistentialType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    declarations = _root_.scala.None
  )
  final val TPE_FIELD_NUMBER = 1
  final val DECLARATIONS_FIELD_NUMBER = 3
  @transient @sharable
  private[semanticdb] val _typemapper_tpe: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    tpe: dotty.tools.dotc.semanticdb.Type,
    declarations: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope]
  ): _root_.dotty.tools.dotc.semanticdb.ExistentialType = _root_.dotty.tools.dotc.semanticdb.ExistentialType(
    tpe,
    declarations
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ExistentialType])
}

@SerialVersionUID(0L)
final case class UniversalType(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None,
    tpe: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.UniversalType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (typeParameters.isDefined) {
        val __value = typeParameters.get
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = dotty.tools.dotc.semanticdb.UniversalType._typemapper_tpe.toBase(tpe)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.UniversalType._typemapper_tpe.toBase(tpe)
        if (__v.serializedSize != 0) {
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      typeParameters.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def getTypeParameters: dotty.tools.dotc.semanticdb.Scope = typeParameters.getOrElse(dotty.tools.dotc.semanticdb.Scope.defaultInstance)
    def clearTypeParameters: UniversalType = copy(typeParameters = _root_.scala.None)
    def withTypeParameters(__v: dotty.tools.dotc.semanticdb.Scope): UniversalType = copy(typeParameters = Option(__v))
    def withTpe(__v: dotty.tools.dotc.semanticdb.Type): UniversalType = copy(tpe = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.UniversalType])
}

object UniversalType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.UniversalType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.UniversalType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.UniversalType = {
    var __typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope] = _root_.scala.None
    var __tpe: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 26 =>
          __typeParameters = Option(__typeParameters.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.Scope](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __tpe = _root_.scala.Some(__tpe.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.UniversalType(
        typeParameters = __typeParameters,
        tpe = dotty.tools.dotc.semanticdb.UniversalType._typemapper_tpe.toCustom(__tpe.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.UniversalType(
    typeParameters = _root_.scala.None,
    tpe = dotty.tools.dotc.semanticdb.UniversalType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
  )
  final val TYPE_PARAMETERS_FIELD_NUMBER = 3
  final val TPE_FIELD_NUMBER = 2
  @transient @sharable
  private[semanticdb] val _typemapper_tpe: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    typeParameters: _root_.scala.Option[dotty.tools.dotc.semanticdb.Scope],
    tpe: dotty.tools.dotc.semanticdb.Type
  ): _root_.dotty.tools.dotc.semanticdb.UniversalType = _root_.dotty.tools.dotc.semanticdb.UniversalType(
    typeParameters,
    tpe
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.UniversalType])
}

@SerialVersionUID(0L)
final case class ByNameType(
    tpe: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.ByNameType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.ByNameType._typemapper_tpe.toBase(tpe)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.ByNameType._typemapper_tpe.toBase(tpe)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
    }
    def withTpe(__v: dotty.tools.dotc.semanticdb.Type): ByNameType = copy(tpe = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.ByNameType])
}

object ByNameType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ByNameType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ByNameType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.ByNameType = {
    var __tpe: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __tpe = _root_.scala.Some(__tpe.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.ByNameType(
        tpe = dotty.tools.dotc.semanticdb.ByNameType._typemapper_tpe.toCustom(__tpe.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.ByNameType(
    tpe = dotty.tools.dotc.semanticdb.ByNameType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
  )
  final val TPE_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_tpe: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    tpe: dotty.tools.dotc.semanticdb.Type
  ): _root_.dotty.tools.dotc.semanticdb.ByNameType = _root_.dotty.tools.dotc.semanticdb.ByNameType(
    tpe
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.ByNameType])
}

@SerialVersionUID(0L)
final case class RepeatedType(
    tpe: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.RepeatedType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.RepeatedType._typemapper_tpe.toBase(tpe)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.RepeatedType._typemapper_tpe.toBase(tpe)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
    }
    def withTpe(__v: dotty.tools.dotc.semanticdb.Type): RepeatedType = copy(tpe = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.RepeatedType])
}

object RepeatedType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.RepeatedType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.RepeatedType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.RepeatedType = {
    var __tpe: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __tpe = _root_.scala.Some(__tpe.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.RepeatedType(
        tpe = dotty.tools.dotc.semanticdb.RepeatedType._typemapper_tpe.toCustom(__tpe.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.RepeatedType(
    tpe = dotty.tools.dotc.semanticdb.RepeatedType._typemapper_tpe.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
  )
  final val TPE_FIELD_NUMBER = 1
  @transient @sharable
  private[semanticdb] val _typemapper_tpe: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    tpe: dotty.tools.dotc.semanticdb.Type
  ): _root_.dotty.tools.dotc.semanticdb.RepeatedType = _root_.dotty.tools.dotc.semanticdb.RepeatedType(
    tpe
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.RepeatedType])
}

@SerialVersionUID(0L)
final case class MatchType(
    scrutinee: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.MatchType._typemapper_scrutinee.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    cases: _root_.scala.Seq[dotty.tools.dotc.semanticdb.MatchType.CaseType] = _root_.scala.Seq.empty
    )  extends dotty.tools.dotc.semanticdb.Type.NonEmpty with SemanticdbGeneratedMessage  derives CanEqual {
    @transient @sharable
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = dotty.tools.dotc.semanticdb.MatchType._typemapper_scrutinee.toBase(scrutinee)
        if (__value.serializedSize != 0) {
          __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        }
      };
      cases.foreach { __item =>
        val __value = __item
        __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
      {
        val __v = dotty.tools.dotc.semanticdb.MatchType._typemapper_scrutinee.toBase(scrutinee)
        if (__v.serializedSize != 0) {
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        }
      };
      cases.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def withScrutinee(__v: dotty.tools.dotc.semanticdb.Type): MatchType = copy(scrutinee = __v)
    def clearCases = copy(cases = _root_.scala.Seq.empty)
    def addCases(__vs: dotty.tools.dotc.semanticdb.MatchType.CaseType *): MatchType = addAllCases(__vs)
    def addAllCases(__vs: Iterable[dotty.tools.dotc.semanticdb.MatchType.CaseType]): MatchType = copy(cases = cases ++ __vs)
    def withCases(__v: _root_.scala.Seq[dotty.tools.dotc.semanticdb.MatchType.CaseType]): MatchType = copy(cases = __v)
    
    
    
    
    // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.MatchType])
}

object MatchType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MatchType] {
  implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MatchType] = this
  def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.MatchType = {
    var __scrutinee: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
    val __cases: _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.MatchType.CaseType] = new _root_.scala.collection.immutable.VectorBuilder[dotty.tools.dotc.semanticdb.MatchType.CaseType]
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __scrutinee = _root_.scala.Some(__scrutinee.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
        case 18 =>
          __cases += LiteParser.readMessage[dotty.tools.dotc.semanticdb.MatchType.CaseType](_input__)
        case tag => _input__.skipField(tag)
      }
    }
    dotty.tools.dotc.semanticdb.MatchType(
        scrutinee = dotty.tools.dotc.semanticdb.MatchType._typemapper_scrutinee.toCustom(__scrutinee.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
        cases = __cases.result()
    )
  }
  
  
  
  
  
  
  lazy val defaultInstance = dotty.tools.dotc.semanticdb.MatchType(
    scrutinee = dotty.tools.dotc.semanticdb.MatchType._typemapper_scrutinee.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
    cases = _root_.scala.Seq.empty
  )
  @SerialVersionUID(0L)
  final case class CaseType(
      key: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_key.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
      body: dotty.tools.dotc.semanticdb.Type = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_body.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
      )  extends SemanticdbGeneratedMessage  derives CanEqual {
      @transient @sharable
      private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
      private[this] def __computeSerializedSize(): _root_.scala.Int = {
        var __size = 0
        
        {
          val __value = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_key.toBase(key)
          if (__value.serializedSize != 0) {
            __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
          }
        };
        
        {
          val __value = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_body.toBase(body)
          if (__value.serializedSize != 0) {
            __size += 1 + SemanticdbOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
          }
        };
        __size
      }
      override def serializedSize: _root_.scala.Int = {
        var __size = __serializedSizeMemoized
        if (__size == 0) {
          __size = __computeSerializedSize() + 1
          __serializedSizeMemoized = __size
        }
        __size - 1
        
      }
      def writeTo(`_output__`: SemanticdbOutputStream): _root_.scala.Unit = {
        {
          val __v = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_key.toBase(key)
          if (__v.serializedSize != 0) {
            _output__.writeTag(1, 2)
            _output__.writeUInt32NoTag(__v.serializedSize)
            __v.writeTo(_output__)
          }
        };
        {
          val __v = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_body.toBase(body)
          if (__v.serializedSize != 0) {
            _output__.writeTag(2, 2)
            _output__.writeUInt32NoTag(__v.serializedSize)
            __v.writeTo(_output__)
          }
        };
      }
      def withKey(__v: dotty.tools.dotc.semanticdb.Type): CaseType = copy(key = __v)
      def withBody(__v: dotty.tools.dotc.semanticdb.Type): CaseType = copy(body = __v)
      
      
      
      
      // @@protoc_insertion_point(GeneratedMessage[dotty.tools.dotc.semanticdb.MatchType.CaseType])
  }
  
  object CaseType  extends SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MatchType.CaseType] {
    implicit def messageCompanion: SemanticdbGeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MatchType.CaseType] = this
    def parseFrom(`_input__`: SemanticdbInputStream): dotty.tools.dotc.semanticdb.MatchType.CaseType = {
      var __key: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
      var __body: _root_.scala.Option[dotty.tools.dotc.semanticdb.TypeMessage] = _root_.scala.None
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __key = _root_.scala.Some(__key.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
          case 18 =>
            __body = _root_.scala.Some(__body.fold(LiteParser.readMessage[dotty.tools.dotc.semanticdb.TypeMessage](_input__))(LiteParser.readMessage(_input__, _)))
          case tag => _input__.skipField(tag)
        }
      }
      dotty.tools.dotc.semanticdb.MatchType.CaseType(
          key = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_key.toCustom(__key.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)),
          body = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_body.toCustom(__body.getOrElse(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance))
      )
    }
    
    
    
    
    
    
    lazy val defaultInstance = dotty.tools.dotc.semanticdb.MatchType.CaseType(
      key = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_key.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance),
      body = dotty.tools.dotc.semanticdb.MatchType.CaseType._typemapper_body.toCustom(dotty.tools.dotc.semanticdb.TypeMessage.defaultInstance)
    )
    final val KEY_FIELD_NUMBER = 1
    final val BODY_FIELD_NUMBER = 2
    @transient @sharable
    private[semanticdb] val _typemapper_key: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
    @transient @sharable
    private[semanticdb] val _typemapper_body: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
    def of(
      key: dotty.tools.dotc.semanticdb.Type,
      body: dotty.tools.dotc.semanticdb.Type
    ): _root_.dotty.tools.dotc.semanticdb.MatchType.CaseType = _root_.dotty.tools.dotc.semanticdb.MatchType.CaseType(
      key,
      body
    )
    // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MatchType.CaseType])
  }
  
  final val SCRUTINEE_FIELD_NUMBER = 1
  final val CASES_FIELD_NUMBER = 2
  @transient @sharable
  private[semanticdb] val _typemapper_scrutinee: SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type] = implicitly[SemanticdbTypeMapper[dotty.tools.dotc.semanticdb.TypeMessage, dotty.tools.dotc.semanticdb.Type]]
  def of(
    scrutinee: dotty.tools.dotc.semanticdb.Type,
    cases: _root_.scala.Seq[dotty.tools.dotc.semanticdb.MatchType.CaseType]
  ): _root_.dotty.tools.dotc.semanticdb.MatchType = _root_.dotty.tools.dotc.semanticdb.MatchType(
    scrutinee,
    cases
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[dotty.tools.dotc.semanticdb.MatchType])
}
